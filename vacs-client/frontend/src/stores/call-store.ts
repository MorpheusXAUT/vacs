import {create} from "zustand/react";
import {invokeStrict} from "../error.ts";
import {useErrorOverlayStore} from "./error-overlay-store.ts";
import {useAuthStore} from "./auth-store.ts";
import {Call, CallSource, CallTarget} from "../types/call.ts";
import {CallId, ClientId, StationId} from "../types/generic.ts";
import {useConnectionStore} from "./connection-store.ts";
import {useCallListStore} from "./call-list-store.ts";
import {useStationsStore} from "./stations-store.ts";

type ConnectionState = "connecting" | "connected" | "disconnected";

type CallDisplay = {
    type: "outgoing" | "accepted" | "rejected" | "error";
    call: Call;
    targetClientId?: ClientId;
    errorReason?: string;
    connectionState?: ConnectionState;
};

type CallState = {
    blink: boolean;
    blinkTimeoutId: number | undefined;
    callDisplay?: CallDisplay;
    incomingCalls: Call[];
    actions: {
        setOutgoingCall: (call: Call) => void;
        acceptIncomingCall: (callId: CallId) => void;
        setOutgoingCallAccepted: (calLId: CallId, targetClientId: ClientId) => void;
        endCall: () => void;
        addIncomingCall: (call: Call) => void;
        removeCall: (id: CallId, callEnd?: boolean) => void;
        rejectCall: (id: CallId) => void;
        dismissRejectedCall: () => void;
        errorCall: (id: CallId, reason: string) => void;
        dismissErrorCall: () => void;
        setConnectionState: (id: CallId, connectionState: ConnectionState) => void;
        reset: () => void;
    };
};

export const useCallStore = create<CallState>()((set, get) => ({
    blink: false,
    blinkTimeoutId: undefined,
    callDisplay: undefined,
    incomingCalls: [],
    connecting: false,
    actions: {
        setOutgoingCall: call => {
            set({callDisplay: {type: "outgoing", call, connectionState: undefined}});
        },
        acceptIncomingCall: callId => {
            const incomingCall = get().incomingCalls.find(call => call.callId === callId);
            if (incomingCall === undefined) return;

            const incomingCalls = get().incomingCalls.filter(info => info.callId !== callId);

            if (shouldStopBlinking(incomingCalls.length, get().callDisplay)) {
                clearTimeout(get().blinkTimeoutId);
                set({blink: false, blinkTimeoutId: undefined, incomingCalls: []});
            }

            set({
                callDisplay: {
                    type: "accepted",
                    call: incomingCall,
                    targetClientId: incomingCall.source.clientId,
                    connectionState: "connecting",
                },
                incomingCalls,
            });
        },
        setOutgoingCallAccepted: (callId, targetClientId) => {
            const callDisplay = get().callDisplay;

            if (callDisplay?.type !== "outgoing" || callDisplay.call.callId !== callId) return;

            set({
                callDisplay: {
                    ...callDisplay,
                    type: "accepted",
                    targetClientId,
                    connectionState: "connecting",
                },
            });
        },
        endCall: () => {
            set({callDisplay: undefined});
        },
        addIncomingCall: call => {
            const incomingCalls = get().incomingCalls.filter(info => info.callId !== call.callId);

            if (get().blinkTimeoutId === undefined) {
                startBlink(set);
            }

            set({incomingCalls: [...incomingCalls, call]});
        },
        removeCall: (callId, callEnd) => {
            const incomingCalls = get().incomingCalls.filter(info => info.callId !== callId);

            if (shouldStopBlinking(incomingCalls.length, get().callDisplay)) {
                clearTimeout(get().blinkTimeoutId);
                set({blink: false, blinkTimeoutId: undefined, incomingCalls: []});
            } else {
                set({incomingCalls});
            }

            const callDisplay = get().callDisplay;
            if (
                callDisplay?.call.callId === callId &&
                callDisplay?.type !== "error" &&
                (!callEnd || callDisplay?.type !== "outgoing")
            ) {
                set({callDisplay: undefined});
            }
        },
        rejectCall: callId => {
            const callDisplay = get().callDisplay;

            if (
                callDisplay === undefined ||
                callDisplay.call.callId !== callId ||
                callDisplay.type !== "outgoing"
            ) {
                get().actions.removeCall(callId);
                return;
            }

            set({
                callDisplay: {type: "rejected", call: callDisplay.call, connectionState: undefined},
            });

            if (get().blinkTimeoutId === undefined) {
                startBlink(set);
            }
        },
        dismissRejectedCall: () => {
            set({callDisplay: undefined});

            if (shouldStopBlinking(get().incomingCalls.length, undefined)) {
                clearTimeout(get().blinkTimeoutId);
                set({blink: false, blinkTimeoutId: undefined});
            }
        },
        errorCall: (callId, reason) => {
            const callDisplay = get().callDisplay;

            if (
                callDisplay === undefined ||
                callDisplay.call.callId !== callId ||
                callDisplay.type === "rejected"
            ) {
                get().actions.removeCall(callId);
                return;
            }

            set({
                callDisplay: {
                    type: "error",
                    call: callDisplay.call,
                    errorReason: reason,
                    connectionState: undefined,
                },
            });

            if (get().blinkTimeoutId === undefined) {
                startBlink(set);
            }
        },
        dismissErrorCall: () => {
            set({callDisplay: undefined});

            if (shouldStopBlinking(get().incomingCalls.length, undefined)) {
                clearTimeout(get().blinkTimeoutId);
                set({blink: false, blinkTimeoutId: undefined});
            }
        },
        setConnectionState: (callId, connectionState) => {
            const callDisplay = get().callDisplay;

            if (callDisplay === undefined || callDisplay.call.callId !== callId) {
                return;
            }

            set({callDisplay: {...callDisplay, connectionState}});
        },
        reset: () => {
            clearTimeout(get().blinkTimeoutId);
            set({
                callDisplay: undefined,
                incomingCalls: [],
                blink: false,
                blinkTimeoutId: undefined,
            });
        },
    },
}));

const shouldStopBlinking = (incomingCallsLength: number, callDisplay?: CallDisplay) => {
    return (
        incomingCallsLength === 0 &&
        (callDisplay === undefined ||
            (callDisplay.type !== "rejected" && callDisplay.type !== "error"))
    );
};

const startBlink = (set: StateSetter) => {
    const toggleBlink = (blink: boolean) => {
        const timeoutId = setTimeout(() => {
            toggleBlink(!blink);
        }, 500);
        set({blinkTimeoutId: timeoutId, blink: blink});
    };
    toggleBlink(true);
};

type StateSetter = {
    (
        partial:
            | CallState
            | Partial<CallState>
            | ((state: CallState) => CallState | Partial<CallState>),
        replace?: false,
    ): void;
    (state: CallState | ((state: CallState) => CallState), replace: true): void;
};

export const startCall = async (target: CallTarget) => {
    const {cid} = useAuthStore.getState();
    const openErrorOverlay = useErrorOverlayStore.getState().open;

    if (target.client === cid) {
        openErrorOverlay("Call error", "You cannot call yourself", false, 5000);
        return;
    }

    const {info} = useConnectionStore.getState();
    const {addOutgoingCall: addOutgoingCallToCallList} = useCallListStore.getState().actions;
    const {setOutgoingCall} = useCallStore.getState().actions;
    const {defaultSource, temporarySource, setTemporarySource} = useStationsStore.getState();

    let stationId: StationId | undefined;
    if (temporarySource !== undefined) {
        stationId = temporarySource;
        setTemporarySource(undefined);
    } else if (defaultSource !== undefined) {
        stationId = defaultSource;
    }

    const source: CallSource = {
        clientId: cid,
        positionId: info.positionId,
        stationId,
    };

    try {
        const callId = await invokeStrict<CallId>("signaling_start_call", {source, target});
        setOutgoingCall({callId, source, target});
        addOutgoingCallToCallList({callId, target});
    } catch {}
};
