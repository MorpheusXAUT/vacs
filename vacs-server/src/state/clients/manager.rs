use crate::metrics::guards::ClientConnectionGuard;
use crate::state::clients::session::ClientSession;
use crate::state::clients::{ClientManagerError, Result};
use std::collections::{HashMap, HashSet};
use tokio::sync::broadcast::error::SendError;
use tokio::sync::{RwLock, broadcast, mpsc};
use tracing::instrument;
use vacs_protocol::profile::{ActiveProfile, ProfileId};
use vacs_protocol::vatsim::{ClientId, PositionId, StationChange, StationId};
use vacs_protocol::ws::server;
use vacs_protocol::ws::server::{
    ClientInfo, DisconnectReason, ServerMessage, SessionProfile, StationInfo,
};
use vacs_vatsim::coverage::network::{Network, RelevantStations};
use vacs_vatsim::coverage::position::Position;
use vacs_vatsim::coverage::profile::Profile;
use vacs_vatsim::{ControllerInfo, FacilityType};

#[derive(Debug)]
pub struct ClientManager {
    broadcast_tx: broadcast::Sender<ServerMessage>,
    network: parking_lot::RwLock<Network>,
    clients: RwLock<HashMap<ClientId, ClientSession>>,
    online_positions: RwLock<HashMap<PositionId, HashSet<ClientId>>>,
    online_stations: RwLock<HashMap<StationId, PositionId>>,
    vatsim_only_positions: RwLock<HashSet<PositionId>>,
}

impl ClientManager {
    pub fn new(broadcast_tx: broadcast::Sender<ServerMessage>, network: Network) -> Self {
        Self {
            broadcast_tx,
            network: parking_lot::RwLock::new(network),
            clients: RwLock::new(HashMap::new()),
            online_positions: RwLock::new(HashMap::new()),
            online_stations: RwLock::new(HashMap::new()),
            vatsim_only_positions: RwLock::new(HashSet::new()),
        }
    }

    #[instrument(level = "debug", skip(self))]
    pub fn find_positions(&self, controller_info: &ControllerInfo) -> Vec<Position> {
        self.network
            .read()
            .find_positions(
                &controller_info.callsign,
                &controller_info.frequency,
                controller_info.facility_type,
            )
            .into_iter()
            .cloned()
            .collect()
    }

    pub fn get_profile(&self, profile_id: Option<&ProfileId>) -> Option<Profile> {
        profile_id.and_then(|profile_id| self.network.read().get_profile(profile_id).cloned())
    }

    pub fn get_position(&self, position_id: Option<&PositionId>) -> Option<Position> {
        position_id.and_then(|position_id| self.network.read().get_position(position_id).cloned())
    }

    pub async fn clients_for_position(&self, position_id: &PositionId) -> HashSet<ClientId> {
        self.online_positions
            .read()
            .await
            .get(position_id)
            .cloned()
            .unwrap_or_default()
    }

    pub async fn clients_for_station(&self, station_id: &StationId) -> HashSet<ClientId> {
        let Some(position_id) = self.online_stations.read().await.get(station_id).cloned() else {
            return HashSet::new();
        };
        self.clients_for_position(&position_id).await
    }

    #[instrument(level = "debug", skip(self, client_connection_guard), err)]
    pub async fn add_client(
        &self,
        client_info: ClientInfo,
        active_profile: ActiveProfile<ProfileId>,
        client_connection_guard: ClientConnectionGuard,
    ) -> Result<(ClientSession, mpsc::Receiver<ServerMessage>)> {
        tracing::trace!("Adding client");

        if self.clients.read().await.contains_key(&client_info.id) {
            tracing::trace!("Client already exists");
            return Err(ClientManagerError::DuplicateClient(
                client_info.id.to_string(),
            ));
        }

        let (tx, rx) = mpsc::channel(crate::config::CLIENT_CHANNEL_CAPACITY);

        let client = ClientSession::new(
            client_info.clone(),
            active_profile,
            tx,
            client_connection_guard,
        );
        self.clients
            .write()
            .await
            .insert(client_info.id.clone(), client.clone());

        let changes = if let Some(position_id) = client.position_id() {
            let mut online_positions = self.online_positions.write().await;

            let exists_and_not_empty = online_positions
                .get(position_id)
                .map(|c| !c.is_empty())
                .unwrap_or(false);

            if exists_and_not_empty {
                tracing::trace!(
                    ?position_id,
                    "Position already exists in online positions list, adding client to list of controllers"
                );
                online_positions
                    .get_mut(position_id)
                    .unwrap()
                    .insert(client_info.id.clone());
                Vec::new()
            } else {
                tracing::trace!(?position_id, "Adding position to online positions list");
                let mut vatsim_only = self.vatsim_only_positions.write().await;
                let was_vatsim_only = vatsim_only.remove(position_id);

                if was_vatsim_only {
                    drop(vatsim_only);

                    tracing::debug!(
                        ?position_id,
                        "Position was VATSIM-only, transitioning to vacs"
                    );

                    online_positions
                        .insert(position_id.clone(), HashSet::from([client_info.id.clone()]));

                    // The total set of online positions hasn't changed (the
                    // position was already counted via vatsim_only), so there
                    // are no actual coverage changes. However, stations
                    // controlled by this position were invisible to vacs clients
                    // (they received Offline when the position became
                    // VATSIM-only) and now need Online events.
                    let online_stations = self.online_stations.read().await;
                    online_stations
                        .iter()
                        .filter(|(_, controlling_pos)| *controlling_pos == position_id)
                        .map(|(station_id, _)| StationChange::Online {
                            station_id: station_id.clone(),
                            position_id: position_id.clone(),
                        })
                        .collect()
                } else {
                    let all_positions: HashSet<&PositionId> =
                        online_positions.keys().chain(vatsim_only.iter()).collect();
                    let all_changes = self.network.read().coverage_changes(
                        None,
                        Some(position_id),
                        &all_positions,
                    );
                    drop(vatsim_only);

                    online_positions
                        .insert(position_id.clone(), HashSet::from([client_info.id.clone()]));

                    tracing::trace!(
                        ?position_id,
                        "Updating online stations list after position addition"
                    );
                    self.update_online_stations(&all_changes).await;
                    Self::client_visible_changes(&all_changes, &online_positions)
                }
            }
        } else {
            tracing::trace!(
                "Client has no position, skipping online positions list addition and station changes broadcast"
            );
            Vec::new()
        };

        if let Err(err) = self.broadcast(server::ClientConnected {
            client: client_info,
        }) {
            tracing::warn!(?err, "Failed to broadcast client connected message");
        }

        self.broadcast_station_changes(&changes).await;

        tracing::trace!("Client added");
        Ok((client, rx))
    }

    #[instrument(level = "debug", skip(self))]
    pub async fn remove_client(
        &self,
        client_id: ClientId,
        disconnect_reason: Option<DisconnectReason>,
    ) {
        tracing::trace!("Removing client");

        let Some(client) = self.clients.write().await.remove(&client_id) else {
            tracing::debug!("Client not found in client list, skipping removal");
            return;
        };

        let changes = if let Some(position_id) = client.position_id() {
            let mut online_positions = self.online_positions.write().await;

            if online_positions.contains_key(position_id) {
                let mut changes = Vec::new();

                if online_positions.get(position_id).unwrap().len() == 1 {
                    tracing::trace!(?position_id, "Removing position from online positions list");

                    let vatsim_only = self.vatsim_only_positions.read().await;
                    let before_all: HashSet<&PositionId> =
                        online_positions.keys().chain(vatsim_only.iter()).collect();
                    let mut after_all = before_all.clone();
                    after_all.remove(position_id);
                    let all_changes = self.network.read().coverage_diff(&before_all, &after_all);
                    drop(vatsim_only);

                    online_positions.remove(position_id);

                    tracing::trace!(
                        ?position_id,
                        "Updating online stations list after position removal"
                    );
                    self.update_online_stations(&all_changes).await;
                    changes.extend(Self::client_visible_changes(
                        &all_changes,
                        &online_positions,
                    ));
                } else {
                    tracing::trace!(
                        ?position_id,
                        "Removing client from position in online positions list"
                    );
                    online_positions
                        .get_mut(position_id)
                        .unwrap()
                        .remove(&client_id);
                }

                changes
            } else {
                tracing::trace!(
                    ?position_id,
                    "Position not found in online positions list, skipping removal of client from list of controllers"
                );
                Vec::new()
            }
        } else {
            tracing::trace!(
                "Client has no position, skipping online positions list removal and station changes broadcast"
            );
            Vec::new()
        };
        client.disconnect(disconnect_reason);

        if let Err(err) = self.broadcast(server::ClientDisconnected { client_id }) {
            tracing::warn!(?err, "Failed to broadcast client disconnected message");
        }

        if self.clients.read().await.is_empty() {
            tracing::debug!(
                "Last client disconnected, clearing VATSIM-only positions and online stations"
            );
            self.vatsim_only_positions.write().await.clear();
            self.online_stations.write().await.clear();
        }

        self.broadcast_station_changes(&changes).await;

        tracing::debug!("Client removed");
    }

    pub async fn list_clients(&self, self_client_id: Option<&ClientId>) -> Vec<ClientInfo> {
        let mut clients: Vec<ClientInfo> = self
            .clients
            .read()
            .await
            .values()
            .filter(|c| self_client_id.map(|s| s != c.id()).unwrap_or(true))
            .map(|c| c.client_info().clone())
            .collect();

        clients.sort_by(|a, b| a.id.cmp(&b.id));
        clients
    }

    pub async fn list_stations(
        &self,
        profile: &ActiveProfile<ProfileId>,
        self_position_id: Option<&PositionId>,
    ) -> Vec<StationInfo> {
        // Resolve relevant station IDs synchronously to avoid holding parking_lot
        // lock across await points
        let relevant_station_ids = {
            let network = self.network.read();
            match network.relevant_stations(profile) {
                RelevantStations::All => None,
                RelevantStations::Subset(ids) => Some(ids.clone()),
                RelevantStations::None => return Vec::new(),
            }
        };
        let online_stations = self.online_stations.read().await;
        let online_positions = self.online_positions.read().await;

        let mut stations: Vec<StationInfo> = match relevant_station_ids {
            None => online_stations
                .iter()
                .filter(|(_, position_id)| online_positions.contains_key(*position_id))
                .map(|(id, controller)| {
                    let own = self_position_id
                        .map(|self_pos| controller == self_pos)
                        .unwrap_or(false);
                    StationInfo {
                        id: id.clone(),
                        own,
                    }
                })
                .collect(),
            Some(ids) => ids
                .iter()
                .filter_map(|id| {
                    online_stations.get(id).and_then(|controller| {
                        online_positions.contains_key(controller).then(|| {
                            let own = self_position_id
                                .map(|self_pos| controller == self_pos)
                                .unwrap_or(false);
                            StationInfo {
                                id: id.clone(),
                                own,
                            }
                        })
                    })
                })
                .collect(),
        };

        stations.sort_by(|a, b| a.id.cmp(&b.id));
        stations
    }

    pub async fn get_client(&self, client_id: &ClientId) -> Option<ClientSession> {
        self.clients.read().await.get(client_id).cloned()
    }

    pub async fn is_client_connected(&self, client_id: &ClientId) -> bool {
        self.clients.read().await.contains_key(client_id)
    }

    pub async fn is_empty(&self) -> bool {
        self.clients.read().await.is_empty()
    }

    #[allow(clippy::result_large_err)]
    pub fn broadcast(
        &self,
        message: impl Into<ServerMessage>,
    ) -> Result<usize, SendError<ServerMessage>> {
        let message = message.into();
        if self.broadcast_tx.receiver_count() > 0 {
            tracing::trace!(message_variant = message.variant(), "Broadcasting message");
            self.broadcast_tx.send(message)
        } else {
            tracing::trace!(
                message_variant = message.variant(),
                "No receivers subscribed, skipping message broadcast"
            );
            Ok(0)
        }
    }

    pub async fn replace_network(&self, network: Network) {
        tracing::info!(?network, "Replacing network coverage data");
        *self.network.write() = network;

        tracing::debug!("Network coverage data replaced, starting housekeeping");

        let old_online_stations = self.online_stations.read().await.clone();

        let mut online_positions = self.online_positions.write().await;
        let mut clients = self.clients.write().await;
        let mut vatsim_only = self.vatsim_only_positions.write().await;

        let (session_updates, new_online_stations) = {
            let network = self.network.read();
            let mut session_updates: Vec<(ClientSession, server::SessionInfo)> = Vec::new();

            // Remove positions that no longer exist in the new network
            let stale_positions: Vec<PositionId> = online_positions
                .keys()
                .filter(|pos_id| network.get_position(pos_id).is_none())
                .cloned()
                .collect();

            for stale_pos_id in &stale_positions {
                tracing::debug!(
                    ?stale_pos_id,
                    "Position no longer exists in new network, removing"
                );
                if let Some(client_ids) = online_positions.remove(stale_pos_id) {
                    for client_id in client_ids {
                        if let Some(session) = clients.get_mut(&client_id) {
                            tracing::debug!(
                                ?client_id,
                                ?stale_pos_id,
                                "Clearing stale position from client"
                            );
                            session.set_position_id(None);
                            let session_profile = session.update_active_profile(None, &network);
                            session_updates.push((
                                session.clone(),
                                server::SessionInfo {
                                    client: session.client_info().clone(),
                                    profile: session_profile,
                                },
                            ));
                        }
                    }
                }
            }

            // Remove VATSIM-only positions that no longer exist in the new network
            let stale_vatsim_only: Vec<PositionId> = vatsim_only
                .iter()
                .filter(|pos_id| network.get_position(pos_id).is_none())
                .cloned()
                .collect();

            for stale_pos_id in &stale_vatsim_only {
                tracing::debug!(
                    ?stale_pos_id,
                    "VATSIM-only position no longer exists in new network, removing"
                );
                vatsim_only.remove(stale_pos_id);
            }

            // Re-transmit profiles for all clients on surviving positions.
            // Profile *content* may change during a dataset reload even when
            // the profile ID stays the same, and we cannot cheaply detect
            // content changes, so we always send the resolved profile.
            for (pos_id, client_ids) in online_positions.iter() {
                let new_profile_id = network
                    .get_position(pos_id)
                    .and_then(|p| p.profile_id.clone());

                for client_id in client_ids {
                    if let Some(session) = clients.get_mut(client_id) {
                        // Track any profile-ID change internally
                        let _ = session.update_active_profile(new_profile_id.clone(), &network);

                        let session_profile = match session.active_profile() {
                            ActiveProfile::Specific(profile_id) => {
                                match network.get_profile(profile_id) {
                                    Some(profile) => SessionProfile::Changed(
                                        ActiveProfile::Specific(profile.into()),
                                    ),
                                    None => {
                                        tracing::warn!(
                                            ?profile_id,
                                            "Profile not found in new network"
                                        );
                                        SessionProfile::Changed(ActiveProfile::None)
                                    }
                                }
                            }
                            // Custom/None profiles do not require updates as they don't carry network-derived content
                            _ => continue,
                        };

                        tracing::debug!(
                            ?client_id,
                            ?pos_id,
                            "Re-transmitting profile to client after network reload"
                        );
                        session_updates.push((
                            session.clone(),
                            server::SessionInfo {
                                client: session.client_info().clone(),
                                profile: session_profile,
                            },
                        ));
                    }
                }
            }

            // Recalculate the full online stations map from scratch, including
            // VATSIM-only positions for correct coverage computation
            let all_online_pos_ids: HashSet<&PositionId> =
                online_positions.keys().chain(vatsim_only.iter()).collect();

            let mut new_online_stations: HashMap<StationId, PositionId> = HashMap::new();
            let covered = network.covered_stations(None, &all_online_pos_ids);
            for covered_station in covered {
                if let Some(controlling_pos) =
                    network.controlling_position(&covered_station.station.id, &all_online_pos_ids)
                {
                    new_online_stations.insert(
                        covered_station.station.id.clone(),
                        controlling_pos.id.clone(),
                    );
                }
            }

            (session_updates, new_online_stations)
        };

        let all_changes = Self::compute_station_diff(&old_online_stations, &new_online_stations);
        self.update_online_stations(&all_changes).await;
        let station_changes = Self::client_visible_changes(&all_changes, &online_positions);

        drop(vatsim_only);
        drop(clients);
        drop(online_positions);

        for (session, session_info) in session_updates {
            if let Err(err) = session.send_message(session_info).await {
                tracing::warn!(
                    ?err,
                    client_id = ?session.id(),
                    "Failed to send updated session info after network reload"
                );
            }
        }

        self.broadcast_station_changes(&station_changes).await;

        tracing::info!("Network housekeeping completed");
    }

    pub async fn sync_vatsim_state(
        &self,
        controllers: &HashMap<ClientId, ControllerInfo>,
        pending_disconnect: &mut HashSet<ClientId>,
        require_active_connection: bool,
    ) -> Vec<(ClientId, DisconnectReason)> {
        let mut updates: Vec<ServerMessage> = Vec::new();
        let mut disconnected_clients: Vec<(ClientId, DisconnectReason)> = Vec::new();
        let mut coverage_changes: Vec<StationChange> = Vec::new();

        {
            let mut clients = self.clients.write().await;
            let mut online_positions = self.online_positions.write().await;
            let mut vatsim_only = self.vatsim_only_positions.write().await;

            let start_all_positions: HashSet<PositionId> = online_positions
                .keys()
                .chain(vatsim_only.iter())
                .cloned()
                .collect();
            let mut positions_changed = false;

            fn disconnect_or_mark_pending(
                cid: &ClientId,
                pending_disconnect: &mut HashSet<ClientId>,
                disconnected_clients: &mut Vec<(ClientId, DisconnectReason)>,
            ) {
                if pending_disconnect.remove(cid) {
                    tracing::trace!(
                        ?cid,
                        "No active VATSIM connection found after grace period, disconnecting client and sending broadcast"
                    );
                    disconnected_clients
                        .push((cid.clone(), DisconnectReason::NoActiveVatsimConnection));
                } else {
                    tracing::trace!(
                        ?cid,
                        "Client not found in data feed, but active VATSIM connection is required, marking for disconnect"
                    );
                    pending_disconnect.insert(cid.clone());
                }
            }

            for (cid, session) in clients.iter_mut() {
                tracing::trace!(?cid, ?session, "Checking session for client info update");

                match controllers.get(cid) {
                    Some(controller) if controller.facility_type == FacilityType::Unknown => {
                        if require_active_connection {
                            disconnect_or_mark_pending(
                                cid,
                                pending_disconnect,
                                &mut disconnected_clients,
                            );
                        }
                    }
                    None => {
                        if require_active_connection {
                            disconnect_or_mark_pending(
                                cid,
                                pending_disconnect,
                                &mut disconnected_clients,
                            );
                        }
                    }
                    Some(controller) => {
                        if pending_disconnect.remove(cid) {
                            tracing::trace!(
                                ?cid,
                                "Found active VATSIM connection for client again, removing pending disconnect"
                            );
                        }

                        let updated = session.update_client_info(controller);
                        if updated {
                            tracing::trace!(
                                ?cid,
                                ?session,
                                "Client info updated, updating position"
                            );

                            let old_position_id = session.position_id().cloned();
                            let new_positions: Vec<Position> = self
                                .network
                                .read()
                                .find_positions(
                                    &controller.callsign,
                                    &controller.frequency,
                                    controller.facility_type,
                                )
                                .into_iter()
                                .cloned()
                                .collect();

                            let new_position = if new_positions.len() > 1 {
                                tracing::info!(
                                    ?cid,
                                    ?old_position_id,
                                    ?new_positions,
                                    "Multiple positions found for updated client info, disconnecting as ambiguous"
                                );
                                pending_disconnect.remove(cid);
                                disconnected_clients.push((
                                    cid.clone(),
                                    DisconnectReason::AmbiguousVatsimPosition(
                                        new_positions.into_iter().map(|p| p.id.clone()).collect(),
                                    ),
                                ));
                                continue;
                            } else if new_positions.len() == 1 {
                                Some(&new_positions[0])
                            } else {
                                None
                            };
                            let new_position_id = new_position.map(|p| p.id.clone());

                            if old_position_id != new_position_id {
                                tracing::debug!(
                                    ?cid,
                                    ?new_position_id,
                                    ?old_position_id,
                                    "Client position changed"
                                );

                                session.set_position_id(new_position_id.clone());

                                if let Some(old_position_id) = &old_position_id {
                                    if online_positions
                                        .get(old_position_id)
                                        .map(|s| s.len() <= 1)
                                        .unwrap_or(false)
                                    {
                                        tracing::trace!(
                                            ?cid,
                                            ?old_position_id,
                                            "Removing position from online positions list"
                                        );
                                        online_positions.remove(old_position_id);
                                        positions_changed = true;
                                    } else if let Some(clients) =
                                        online_positions.get_mut(old_position_id)
                                    {
                                        tracing::trace!(
                                            ?cid,
                                            ?old_position_id,
                                            "Removing client from position in online positions list"
                                        );
                                        clients.remove(cid);
                                    }
                                }

                                if let Some(new_position_id) = &new_position_id {
                                    let clients = online_positions
                                        .entry(new_position_id.clone())
                                        .or_default();
                                    if clients.insert(cid.clone()) && clients.len() == 1 {
                                        positions_changed = true;
                                    }
                                }

                                let session_profile = {
                                    let network = self.network.read();
                                    session.update_active_profile(
                                        new_position.and_then(|p| p.profile_id.clone()),
                                        &network,
                                    )
                                };

                                if let Err(err) = session
                                    .send_message(server::SessionInfo {
                                        client: session.client_info().clone(),
                                        profile: session_profile,
                                    })
                                    .await
                                {
                                    tracing::warn!(
                                        ?err,
                                        ?session,
                                        "Failed to send updated session info to client"
                                    );
                                }
                            }

                            tracing::trace!(?cid, ?session, "Client info updated, broadcasting");
                            updates.push(ServerMessage::from(session.client_info().clone()));
                        }
                    }
                }
            }

            let vacs_client_ids: HashSet<&ClientId> = clients.keys().collect();
            let mut new_vatsim_only: HashSet<PositionId> = HashSet::new();

            for (cid, controller) in controllers {
                if controller.facility_type == FacilityType::Unknown
                    || vacs_client_ids.contains(cid)
                {
                    continue;
                }
                let positions: Vec<Position> = self
                    .network
                    .read()
                    .find_positions(
                        &controller.callsign,
                        &controller.frequency,
                        controller.facility_type,
                    )
                    .into_iter()
                    .cloned()
                    .collect();
                if positions.len() == 1 && !online_positions.contains_key(&positions[0].id) {
                    new_vatsim_only.insert(positions[0].id.clone());
                }
            }

            if *vatsim_only != new_vatsim_only {
                tracing::debug!(
                    before = vatsim_only.len(),
                    after = new_vatsim_only.len(),
                    "VATSIM-only positions changed"
                );
                *vatsim_only = new_vatsim_only;
                positions_changed = true;
            }

            if positions_changed {
                tracing::debug!("Online positions changed, calculating coverage changes");
                let start_all = start_all_positions.iter().collect::<HashSet<_>>();
                let end_all: HashSet<&PositionId> =
                    online_positions.keys().chain(vatsim_only.iter()).collect();

                let all_changes = self.network.read().coverage_diff(&start_all, &end_all);
                self.update_online_stations(&all_changes).await;
                coverage_changes.extend(Self::client_visible_changes(
                    &all_changes,
                    &online_positions,
                ));
            }
        }

        if self.broadcast_tx.receiver_count() > 0 {
            for msg in updates {
                if let Err(err) = self.broadcast(msg) {
                    tracing::warn!(?err, "Failed to broadcast client info update");
                }
            }
        }

        self.broadcast_station_changes(&coverage_changes).await;

        disconnected_clients
    }

    fn compute_station_diff(
        old: &HashMap<StationId, PositionId>,
        new: &HashMap<StationId, PositionId>,
    ) -> Vec<StationChange> {
        let mut changes = Vec::new();

        // Stations that went offline or changed controller
        for (station_id, old_pos_id) in old {
            match new.get(station_id) {
                None => {
                    changes.push(StationChange::Offline {
                        station_id: station_id.clone(),
                    });
                }
                Some(new_pos_id) if new_pos_id != old_pos_id => {
                    changes.push(StationChange::Handoff {
                        station_id: station_id.clone(),
                        from_position_id: old_pos_id.clone(),
                        to_position_id: new_pos_id.clone(),
                    });
                }
                _ => {}
            }
        }

        // Stations that came online
        for (station_id, new_pos_id) in new {
            if !old.contains_key(station_id) {
                changes.push(StationChange::Online {
                    station_id: station_id.clone(),
                    position_id: new_pos_id.clone(),
                });
            }
        }

        changes.sort();
        changes
    }

    /// Transforms station changes to only include changes visible to vacs clients.
    /// Stations covered solely by VATSIM-only positions are not callable, so:
    /// - `Online` for a VATSIM-only position is dropped
    /// - `Offline` events are always forwarded, even if the previous covering position
    ///   was VATSIM-only. Clients handle duplicate/unknown `Offline` events gracefully.
    /// - `Handoff` to a VATSIM-only position becomes `Offline` (station leaves vacs coverage)
    /// - `Handoff` from a VATSIM-only position becomes `Online` (station enters vacs coverage)
    fn client_visible_changes(
        changes: &[StationChange],
        online_positions: &HashMap<PositionId, HashSet<ClientId>>,
    ) -> Vec<StationChange> {
        changes
            .iter()
            .filter_map(|change| match change {
                StationChange::Online { position_id, .. } => {
                    if online_positions.contains_key(position_id) {
                        Some(change.clone())
                    } else {
                        None
                    }
                }
                StationChange::Handoff {
                    station_id,
                    from_position_id,
                    to_position_id,
                } => {
                    let from_vacs = online_positions.contains_key(from_position_id);
                    let to_vacs = online_positions.contains_key(to_position_id);
                    match (from_vacs, to_vacs) {
                        // vacs -> vacs: normal handoff
                        (true, true) => Some(change.clone()),
                        // vacs -> VATSIM-only: station leaves vacs coverage
                        (true, false) => Some(StationChange::Offline {
                            station_id: station_id.clone(),
                        }),
                        // VATSIM-only -> vacs: station enters vacs coverage
                        (false, true) => Some(StationChange::Online {
                            station_id: station_id.clone(),
                            position_id: to_position_id.clone(),
                        }),
                        // VATSIM-only -> VATSIM-only: invisible to clients
                        (false, false) => None,
                    }
                }
                StationChange::Offline { .. } => Some(change.clone()),
            })
            .collect()
    }

    async fn update_online_stations(&self, changes: &[StationChange]) {
        if changes.is_empty() {
            return;
        }

        let mut online_stations = self.online_stations.write().await;
        for change in changes {
            match change {
                StationChange::Online {
                    station_id,
                    position_id,
                } => {
                    online_stations.insert(station_id.clone(), position_id.clone());
                }
                StationChange::Offline { station_id } => {
                    online_stations.remove(station_id);
                }
                StationChange::Handoff {
                    station_id,
                    to_position_id,
                    ..
                } => {
                    online_stations.insert(station_id.clone(), to_position_id.clone());
                }
            }
        }
    }

    async fn broadcast_station_changes(&self, changes: &[StationChange]) {
        if changes.is_empty() {
            return;
        }

        tracing::trace!("Sending station changes to clients");
        let mut filtered_changes_cache: HashMap<ActiveProfile<ProfileId>, Vec<StationChange>> =
            HashMap::new();

        let clients = self
            .clients
            .read()
            .await
            .values()
            .cloned()
            .collect::<Vec<_>>();

        for client in clients {
            let profile = client.active_profile();

            let changes_to_send = if let Some(cached_changes) = filtered_changes_cache.get(profile)
            {
                cached_changes.clone()
            } else {
                let relevant_station_ids = {
                    let network = self.network.read();
                    match network.relevant_stations(profile) {
                        RelevantStations::All => None,
                        RelevantStations::Subset(ids) => Some(ids.clone()),
                        RelevantStations::None => Some(HashSet::new()),
                    }
                };

                let filtered_changes = match relevant_station_ids {
                    None => changes.to_vec(),
                    Some(relevant_ids) if relevant_ids.is_empty() => Vec::new(),
                    Some(relevant_ids) => changes
                        .iter()
                        .filter(|change| {
                            let station_id = match change {
                                StationChange::Online { station_id, .. } => station_id,
                                StationChange::Offline { station_id } => station_id,
                                StationChange::Handoff { station_id, .. } => station_id,
                            };
                            relevant_ids.contains(station_id)
                        })
                        .cloned()
                        .collect(),
                };

                filtered_changes_cache.insert(profile.clone(), filtered_changes.clone());
                filtered_changes
            };

            if changes_to_send.is_empty() {
                continue;
            }

            if let Err(err) = client
                .send_message(server::StationChanges {
                    changes: changes_to_send,
                })
                .await
            {
                tracing::warn!(?err, ?client, "Failed to send station changes to client");
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;
    use vacs_vatsim::coverage::test_support::TestFirBuilder;

    fn pos(id: &str) -> PositionId {
        PositionId::from(id)
    }

    fn station(id: &str) -> StationId {
        StationId::from(id)
    }

    fn cid(id: &str) -> ClientId {
        ClientId::from(id)
    }

    fn controller(cid: &str, callsign: &str, freq: &str, ft: FacilityType) -> ControllerInfo {
        ControllerInfo {
            cid: ClientId::from(cid),
            callsign: callsign.to_string(),
            frequency: freq.to_string(),
            facility_type: ft,
        }
    }

    fn client_info(id: &str, position_id: &str, freq: &str) -> ClientInfo {
        ClientInfo {
            id: ClientId::from(id),
            position_id: Some(PositionId::from(position_id)),
            display_name: id.to_string(),
            frequency: freq.to_string(),
        }
    }

    fn client_info_without_position(id: &str) -> ClientInfo {
        ClientInfo {
            id: ClientId::from(id),
            position_id: None,
            display_name: id.to_string(),
            frequency: String::new(),
        }
    }

    fn online_positions(entries: &[&str]) -> HashMap<PositionId, HashSet<ClientId>> {
        entries
            .iter()
            .map(|id| (pos(id), HashSet::from([cid("1000000")])))
            .collect()
    }

    fn client_manager(network: Network) -> ClientManager {
        let (tx, _) = broadcast::channel(64);
        ClientManager::new(tx, network)
    }

    /// Drain all pending messages from a client receiver and return only the
    /// station changes, sorted for deterministic comparison.
    fn drain_station_changes(rx: &mut mpsc::Receiver<ServerMessage>) -> Vec<StationChange> {
        let mut changes = Vec::new();
        while let Ok(msg) = rx.try_recv() {
            if let ServerMessage::StationChanges(sc) = msg {
                changes.extend(sc.changes);
            }
        }
        changes.sort();
        changes
    }

    #[test]
    fn online_vacs_position_is_visible() {
        let changes = vec![StationChange::Online {
            station_id: station("LOWW_TWR"),
            position_id: pos("LOWW_TWR"),
        }];
        let positions = online_positions(&["LOWW_TWR"]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert_eq!(result, changes);
    }

    #[test]
    fn online_vatsim_only_position_is_dropped() {
        let changes = vec![StationChange::Online {
            station_id: station("LOWW_TWR"),
            position_id: pos("LOWW_TWR"),
        }];
        let positions = online_positions(&[]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert!(result.is_empty());
    }

    #[test]
    fn handoff_vacs_to_vacs_is_visible() {
        let changes = vec![StationChange::Handoff {
            station_id: station("LOWW_APP"),
            from_position_id: pos("LOVV_CTR"),
            to_position_id: pos("LOWW_APP"),
        }];
        let positions = online_positions(&["LOVV_CTR", "LOWW_APP"]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert_eq!(result, changes);
    }

    #[test]
    fn handoff_vacs_to_vatsim_only_becomes_offline() {
        let changes = vec![StationChange::Handoff {
            station_id: station("LOWW_TWR"),
            from_position_id: pos("LOWW_APP"),
            to_position_id: pos("LOWW_TWR"),
        }];
        let positions = online_positions(&["LOWW_APP"]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert_eq!(
            result,
            vec![StationChange::Offline {
                station_id: station("LOWW_TWR"),
            }]
        );
    }

    #[test]
    fn handoff_vatsim_only_to_vacs_becomes_online() {
        let changes = vec![StationChange::Handoff {
            station_id: station("LOWW_TWR"),
            from_position_id: pos("LOWW_TWR"),
            to_position_id: pos("LOWW_APP"),
        }];
        let positions = online_positions(&["LOWW_APP"]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert_eq!(
            result,
            vec![StationChange::Online {
                station_id: station("LOWW_TWR"),
                position_id: pos("LOWW_APP"),
            }]
        );
    }

    #[test]
    fn handoff_vatsim_only_to_vatsim_only_is_dropped() {
        let changes = vec![StationChange::Handoff {
            station_id: station("LOWW_APP"),
            from_position_id: pos("LOVV_CTR"),
            to_position_id: pos("LOWW_APP"),
        }];
        let positions = online_positions(&[]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert!(result.is_empty());
    }

    #[test]
    fn offline_is_always_visible() {
        let changes = vec![StationChange::Offline {
            station_id: station("LOWW_TWR"),
        }];
        let positions = online_positions(&[]);

        let result = ClientManager::client_visible_changes(&changes, &positions);
        assert_eq!(result, changes);
    }

    #[tokio::test]
    async fn vatsim_only_position_removes_station_from_vacs_client() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx);

        // LOWW_APP should cover LOWW_APP, LOWW_TWR, LOWW_GND, LOWW_DEL stations
        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOWW_APP")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(station_ids.contains(&"LOWW_APP"));
        assert!(station_ids.contains(&"LOWW_TWR"));
        assert!(station_ids.contains(&"LOWW_GND"));
        assert!(station_ids.contains(&"LOWW_DEL"));

        // Now LOWW_TWR comes online on VATSIM only (not on vacs)
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOWW_APP", "134.675", FacilityType::Approach),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);

        let disconnected = manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;
        assert!(disconnected.is_empty());

        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOWW_APP")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(station_ids.contains(&"LOWW_APP"));
        assert!(
            !station_ids.contains(&"LOWW_TWR"),
            "LOWW_TWR should not be listed (VATSIM-only)"
        );
        // LOWW_GND and LOWW_DEL are children of LOWW_TWR, now covered by VATSIM-only LOWW_TWR
        assert!(
            !station_ids.contains(&"LOWW_GND"),
            "LOWW_GND should not be listed (covered by VATSIM-only LOWW_TWR)"
        );
        assert!(
            !station_ids.contains(&"LOWW_DEL"),
            "LOWW_DEL should not be listed (covered by VATSIM-only LOWW_TWR)"
        );

        // But internally, LOWW_TWR station should be tracked in online_stations
        let internal_stations = manager.online_stations.read().await;
        assert!(internal_stations.contains_key(&station("LOWW_TWR")));
        drop(internal_stations);

        // Client should receive Offline for the stations that became vatsim-only
        // (LOWW_APP stays online â€” still covered by vacs LOWW_APP position)
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ]
        );
    }

    #[tokio::test]
    async fn vatsim_only_position_becomes_vacs_when_client_connects() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR (covers everything including LOWW_APP,
        // LOWW_TWR, etc.)
        let (_client, mut rx_ctr) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx_ctr);

        // LOWW_TWR comes online on VATSIM only
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        // LOWW_TWR station is NOT callable (VATSIM-only)
        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOVV_CTR")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(!station_ids.contains(&"LOWW_TWR"));

        // CTR client should have received Offline for stations that became VATSIM-only
        let changes_after_sync = drain_station_changes(&mut rx_ctr);
        assert_eq!(
            changes_after_sync,
            vec![
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ]
        );

        // Now a vacs client connects as LOWW_TWR
        let _client_twr = manager
            .add_client(
                client_info("client2", "LOWW_TWR", "119.400"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOWW_TWR should now be in the list (vacs client covers it)
        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOVV_CTR")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(
            station_ids.contains(&"LOWW_TWR"),
            "LOWW_TWR should be listed after vacs client connects"
        );

        // CTR client should receive Online for stations that transitioned from
        // VATSIM-only to vacs coverage.
        let changes_after_connect = drain_station_changes(&mut rx_ctr);
        assert_eq!(
            changes_after_connect,
            vec![
                StationChange::Online {
                    station_id: station("LOWW_DEL"),
                    position_id: pos("LOWW_TWR"),
                },
                StationChange::Online {
                    station_id: station("LOWW_GND"),
                    position_id: pos("LOWW_TWR"),
                },
                StationChange::Online {
                    station_id: station("LOWW_TWR"),
                    position_id: pos("LOWW_TWR"),
                },
            ]
        );
    }

    #[tokio::test]
    async fn vacs_client_disconnect_with_vatsim_only_covering_same_position() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR
        let (_client_ctr, mut rx_ctr) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // vacs client connects as LOWW_TWR
        let _client_twr = manager
            .add_client(
                client_info("client2", "LOWW_TWR", "119.400"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx_ctr);

        // LOWW_TWR is callable
        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOVV_CTR")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(station_ids.contains(&"LOWW_TWR"));

        // vacs LOWW_TWR client disconnects
        manager
            .remove_client(cid("client2"), Some(DisconnectReason::Terminated))
            .await;

        // CTR client should see LOWW_TWR come back under its control
        let changes_after_disconnect = drain_station_changes(&mut rx_ctr);
        assert_eq!(
            changes_after_disconnect,
            vec![
                StationChange::Online {
                    station_id: station("LOWW_DEL"),
                    position_id: pos("LOVV_CTR"),
                },
                StationChange::Online {
                    station_id: station("LOWW_GND"),
                    position_id: pos("LOVV_CTR"),
                },
                StationChange::Online {
                    station_id: station("LOWW_TWR"),
                    position_id: pos("LOVV_CTR"),
                },
            ]
        );

        // But VATSIM-only LOWW_TWR is still online
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        // After sync, LOWW_TWR becomes VATSIM-only â†’ CTR client sees it go Offline
        let changes_after_sync = drain_station_changes(&mut rx_ctr);
        assert_eq!(
            changes_after_sync,
            vec![
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ]
        );

        // LOWW_TWR should NOT be callable (VATSIM-only now)
        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOVV_CTR")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(
            !station_ids.contains(&"LOWW_TWR"),
            "LOWW_TWR should not be listed (VATSIM-only after vacs client disconnect)"
        );

        // But LOWW_TWR should still be in internal tracking
        let internal_stations = manager.online_stations.read().await;
        assert!(internal_stations.contains_key(&station("LOWW_TWR")));
    }

    #[tokio::test]
    async fn multiple_vatsim_only_positions_not_callable() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR
        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx);

        // Both LOWW_TWR and LOWW_GND online on VATSIM only
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
            (
                cid("vatsim_client2"),
                controller(
                    "vatsim_client2",
                    "LOWW_GND",
                    "121.600",
                    FacilityType::Ground,
                ),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOVV_CTR")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();

        assert!(
            !station_ids.contains(&"LOWW_TWR"),
            "LOWW_TWR should not be callable (vatsim-only)"
        );
        assert!(
            !station_ids.contains(&"LOWW_GND"),
            "LOWW_GND should not be callable (vatsim-only)"
        );
        assert!(
            !station_ids.contains(&"LOWW_DEL"),
            "LOWW_DEL should not be callable (covered by vatsim-only LOWW_GND)"
        );
        // LOWW_APP should still be covered by LOVV_CTR
        assert!(
            station_ids.contains(&"LOWW_APP"),
            "LOWW_APP should still be callable (covered by VACS LOVV_CTR)"
        );

        // Client should receive Offline for all three stations that became VATSIM-only
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ]
        );
    }

    #[tokio::test]
    async fn last_client_disconnect_clears_vatsim_only_state() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects
        let _client = manager
            .add_client(
                client_info("client0", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // Sync with VATSIM-only TWR
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOWW_APP", "134.675", FacilityType::Approach),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        assert!(!manager.vatsim_only_positions.read().await.is_empty());
        assert!(!manager.online_stations.read().await.is_empty());

        // Last vacs client disconnects
        manager
            .remove_client(cid("client0"), Some(DisconnectReason::Terminated))
            .await;

        assert!(
            manager.vatsim_only_positions.read().await.is_empty(),
            "VATSIM-only positions should be cleared after last client disconnects"
        );
        assert!(
            manager.online_stations.read().await.is_empty(),
            "online stations should be cleared after last client disconnects"
        );
    }

    #[tokio::test]
    async fn clients_for_station_returns_empty_for_vatsim_only() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR
        let _client = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOWW_TWR online VATSIM-only
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        // LOWW_TWR station exists internally but has no callable clients
        let clients = manager.clients_for_station(&station("LOWW_TWR")).await;
        assert!(
            clients.is_empty(),
            "clients_for_station should return empty for VATSIM-only station"
        );
    }

    #[tokio::test]
    async fn replace_network_removes_stale_position() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Client connects as LOWW_DEL
        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOWW_DEL", "122.125"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // Drain initial station changes from add_client
        drain_station_changes(&mut rx);

        assert!(
            manager
                .online_positions
                .read()
                .await
                .contains_key(&pos("LOWW_DEL"))
        );

        // Replace with a network that no longer has LOWW_DEL position
        let new_network = create_lovv_network_without_del(dir.path());
        manager.replace_network(new_network).await;

        // Position should be gone
        assert!(
            !manager
                .online_positions
                .read()
                .await
                .contains_key(&pos("LOWW_DEL")),
            "LOWW_DEL position should be removed after network replace"
        );

        // Client's position_id should be cleared
        let client = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(
            client.position_id(),
            None,
            "Client's position_id should be None after their position is removed"
        );

        // Client should receive Offline for LOWW_DEL station
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![StationChange::Offline {
                station_id: station("LOWW_DEL"),
            }]
        );
    }

    #[tokio::test]
    async fn replace_network_removes_stale_station() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Client connects as LOVV_CTR which covers all stations
        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx);

        // LOWW_DEL station should be online
        assert!(
            manager
                .online_stations
                .read()
                .await
                .contains_key(&station("LOWW_DEL"))
        );

        // Replace with network that has no LOWW_DEL station
        let new_network = create_lovv_network_without_del(dir.path());
        manager.replace_network(new_network).await;

        // LOWW_DEL station should be gone
        assert!(
            !manager
                .online_stations
                .read()
                .await
                .contains_key(&station("LOWW_DEL")),
            "LOWW_DEL station should be removed after network replace"
        );

        // Remaining stations (LOWW_APP, LOWW_TWR, LOWW_GND) should still be online
        let online_stations = manager.online_stations.read().await;
        assert!(online_stations.contains_key(&station("LOWW_APP")));
        assert!(online_stations.contains_key(&station("LOWW_TWR")));
        assert!(online_stations.contains_key(&station("LOWW_GND")));
        drop(online_stations);

        // Client should receive exactly Offline for LOWW_DEL
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![StationChange::Offline {
                station_id: station("LOWW_DEL"),
            }],
            "Only LOWW_DEL should go offline"
        );
    }

    #[tokio::test]
    async fn replace_network_adds_new_station() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Client connects as LOVV_CTR
        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx);

        // No LOVV_N1 station initially
        assert!(
            !manager
                .online_stations
                .read()
                .await
                .contains_key(&station("LOVV_N1"))
        );

        // Replace with network that adds LOVV_N1 station controlled by LOVV_CTR
        let new_network = create_lovv_network_with_extra_station(dir.path());
        manager.replace_network(new_network).await;

        // LOVV_N1 should now be online, controlled by LOVV_CTR
        let online_stations = manager.online_stations.read().await;
        assert_eq!(
            online_stations.get(&station("LOVV_N1")),
            Some(&pos("LOVV_CTR")),
            "LOVV_N1 should be online and controlled by LOVV_CTR"
        );
        drop(online_stations);

        // Client should receive Online for LOVV_N1
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![StationChange::Online {
                station_id: station("LOVV_N1"),
                position_id: pos("LOVV_CTR"),
            }]
        );
    }

    #[tokio::test]
    async fn replace_network_updates_station_controller() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // LOVV_CTR connects, covers all stations
        let _client_ctr = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOWW_APP should be controlled by LOVV_CTR (only online position)
        assert_eq!(
            manager
                .online_stations
                .read()
                .await
                .get(&station("LOWW_APP")),
            Some(&pos("LOVV_CTR"))
        );

        // Now LOWW_APP also connects
        let _client_app = manager
            .add_client(
                client_info("client1", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOWW_APP station should now be controlled by LOWW_APP position
        // (higher priority in controlled_by list)
        assert_eq!(
            manager
                .online_stations
                .read()
                .await
                .get(&station("LOWW_APP")),
            Some(&pos("LOWW_APP"))
        );

        // Replace with same network structure â€” controllers should remain
        let new_network = Network::load_from_dir(dir.path()).unwrap();
        manager.replace_network(new_network).await;

        // Station controller assignments should be preserved
        let online = manager.online_stations.read().await;
        assert_eq!(
            online.get(&station("LOWW_APP")),
            Some(&pos("LOWW_APP")),
            "LOWW_APP should still be controlled by LOWW_APP position after no-op reload"
        );
    }

    #[tokio::test]
    async fn replace_network_cleans_vatsim_only_positions() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR
        let _client = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOWW_TWR comes online on VATSIM only
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        assert!(
            manager
                .vatsim_only_positions
                .read()
                .await
                .contains(&pos("LOWW_TWR")),
            "LOWW_TWR should be in vatsim_only"
        );

        // Replace with network that no longer has LOWW_TWR position
        let new_network = create_lovv_network_without_del(dir.path());

        // Verify LOWW_TWR position actually doesn't exist in the new network
        assert!(
            new_network.get_position(&pos("LOWW_TWR")).is_some(),
            "LOWW_TWR position should still exist in the reduced network"
        );

        manager.replace_network(new_network).await;

        // LOWW_TWR position still exists (we only removed DEL), so it stays
        // in vatsim_only
        assert!(
            manager
                .vatsim_only_positions
                .read()
                .await
                .contains(&pos("LOWW_TWR")),
            "LOWW_TWR should still be in vatsim_only (position still exists)"
        );
    }

    #[tokio::test]
    async fn replace_network_removes_nonexistent_vatsim_only() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR
        let _client = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOWW_DEL comes online on VATSIM only
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller(
                    "vatsim_client1",
                    "LOWW_DEL",
                    "122.125",
                    FacilityType::Delivery,
                ),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        assert!(
            manager
                .vatsim_only_positions
                .read()
                .await
                .contains(&pos("LOWW_DEL"))
        );

        // Replace with network that no longer has LOWW_DEL position
        let new_network = create_lovv_network_without_del(dir.path());
        assert!(
            new_network.get_position(&pos("LOWW_DEL")).is_none(),
            "Precondition: LOWW_DEL should not exist in the new network"
        );
        manager.replace_network(new_network).await;

        // LOWW_DEL should be cleaned from vatsim_only
        assert!(
            !manager
                .vatsim_only_positions
                .read()
                .await
                .contains(&pos("LOWW_DEL")),
            "LOWW_DEL should be removed from vatsim_only after network replace"
        );
    }

    #[tokio::test]
    async fn replace_network_with_profile_reassignment() {
        let dir = tempfile::tempdir().unwrap();
        let fir_path = dir.path().join("LOVV");
        std::fs::create_dir(&fir_path).unwrap();

        let network = create_lovv_network_with_profiles(dir.path());
        let manager = client_manager(network);

        // Client connects as LOWW_APP with profile APP_PROFILE
        let _client = manager
            .add_client(
                client_info("client0", "LOWW_APP", "134.675"),
                ActiveProfile::Specific(ProfileId::from("APP_PROFILE")),
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // Verify initial profile
        let client = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(
            client.active_profile(),
            &ActiveProfile::Specific(ProfileId::from("APP_PROFILE")),
        );

        // Replace network where LOWW_APP's profile_id changes to CTR_PROFILE
        let new_network = create_lovv_network_with_reassigned_profile(dir.path());
        manager.replace_network(new_network).await;

        // Client's active profile should now be CTR_PROFILE
        let client = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(
            client.active_profile(),
            &ActiveProfile::Specific(ProfileId::from("CTR_PROFILE")),
            "Client's profile should be updated to CTR_PROFILE after network reload"
        );
    }

    #[tokio::test]
    async fn replace_network_custom_profile_stays_custom() {
        let dir = tempfile::tempdir().unwrap();
        let fir_path = dir.path().join("LOVV");
        std::fs::create_dir(&fir_path).unwrap();

        let network = create_lovv_network_with_profiles(dir.path());
        let manager = client_manager(network);

        // Client connects with Custom profile (user's own selection)
        let _client = manager
            .add_client(
                client_info("client0", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // Replace network where LOWW_APP's profile changes
        let new_network = create_lovv_network_with_reassigned_profile(dir.path());
        manager.replace_network(new_network).await;

        // Client's profile should remain Custom
        let client = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(
            client.active_profile(),
            &ActiveProfile::Custom,
            "Client with Custom profile should remain Custom after network reload"
        );
    }

    #[tokio::test]
    async fn replace_network_no_change_is_noop() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Client connects as LOVV_CTR
        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx);

        let stations_before = manager.online_stations.read().await.clone();
        let positions_before = manager.online_positions.read().await.clone();

        // Reload the exact same network
        let same_network = Network::load_from_dir(dir.path()).unwrap();
        manager.replace_network(same_network).await;

        // Everything should be unchanged
        assert_eq!(
            *manager.online_stations.read().await,
            stations_before,
            "Online stations should be unchanged after no-op reload"
        );
        assert_eq!(
            *manager.online_positions.read().await,
            positions_before,
            "Online positions should be unchanged after no-op reload"
        );

        // Client should still have their position
        let client = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(client.position_id(), Some(&pos("LOVV_CTR")));

        // No station changes should be sent
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![],
            "No station changes should be sent for no-op reload"
        );
    }

    #[tokio::test]
    async fn replace_network_station_coverage_shift() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Two clients online: LOVV_CTR and LOWW_APP
        let (_client_ctr, mut rx_ctr) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();
        let (_client_app, mut rx_app) = manager
            .add_client(
                client_info("client1", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx_ctr);
        drain_station_changes(&mut rx_app);

        // LOWW_APP station controlled by LOWW_APP position
        assert_eq!(
            manager
                .online_stations
                .read()
                .await
                .get(&station("LOWW_APP")),
            Some(&pos("LOWW_APP"))
        );

        // Replace with network where LOWW_APP station's controlled_by only
        // lists LOVV_CTR (removing LOWW_APP from the list)
        let fir_path = dir.path().join("LOVV");
        std::fs::write(
            fir_path.join("stations.toml"),
            r#"
[[stations]]
id = "LOWW_APP"
controlled_by = ["LOVV_CTR"]

[[stations]]
id = "LOWW_TWR"
parent_id = "LOWW_APP"
controlled_by = ["LOWW_TWR"]

[[stations]]
id = "LOWW_GND"
parent_id = "LOWW_TWR"
controlled_by = ["LOWW_GND"]

[[stations]]
id = "LOWW_DEL"
parent_id = "LOWW_GND"
controlled_by = ["LOWW_DEL"]
"#,
        )
        .unwrap();
        let new_network = Network::load_from_dir(dir.path()).unwrap();
        manager.replace_network(new_network).await;

        // LOWW_APP station should now be controlled by LOVV_CTR
        assert_eq!(
            manager
                .online_stations
                .read()
                .await
                .get(&station("LOWW_APP")),
            Some(&pos("LOVV_CTR")),
            "LOWW_APP station should shift to LOVV_CTR after controlled_by change"
        );

        // Both clients should receive Handoffs for all stations moving from
        // LOWW_APP to LOVV_CTR (LOWW_APP position was removed from the network)
        let expected = vec![
            StationChange::Handoff {
                station_id: station("LOWW_APP"),
                from_position_id: pos("LOWW_APP"),
                to_position_id: pos("LOVV_CTR"),
            },
            StationChange::Handoff {
                station_id: station("LOWW_DEL"),
                from_position_id: pos("LOWW_APP"),
                to_position_id: pos("LOVV_CTR"),
            },
            StationChange::Handoff {
                station_id: station("LOWW_GND"),
                from_position_id: pos("LOWW_APP"),
                to_position_id: pos("LOVV_CTR"),
            },
            StationChange::Handoff {
                station_id: station("LOWW_TWR"),
                from_position_id: pos("LOWW_APP"),
                to_position_id: pos("LOVV_CTR"),
            },
        ];
        let changes_ctr = drain_station_changes(&mut rx_ctr);
        assert_eq!(changes_ctr, expected, "LOVV_CTR client");
        let changes_app = drain_station_changes(&mut rx_app);
        assert_eq!(changes_app, expected, "LOWW_APP client");
    }

    #[tokio::test]
    async fn replace_network_vatsim_only_position_removed_stations_become_visible() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOVV_CTR
        let (_client, mut rx) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx);

        // LOWW_TWR comes online as VATSIM-only
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOVV_CTR", "132.600", FacilityType::Enroute),
            ),
            (
                cid("vatsim_client1"),
                controller("vatsim_client1", "LOWW_TWR", "119.400", FacilityType::Tower),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        // Client received Offline for LOWW_TWR/GND/DEL (now VATSIM-only)
        let changes_after_sync = drain_station_changes(&mut rx);
        assert_eq!(
            changes_after_sync,
            vec![
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ]
        );

        // Replace with network that removes LOWW_TWR position entirely
        // â†’ VATSIM-only LOWW_TWR gets cleaned, stations fall back to LOVV_CTR
        let new_network = create_lovv_network_without_twr_position(dir.path());
        manager.replace_network(new_network).await;

        // LOWW_TWR should be removed from vatsim_only
        assert!(
            !manager
                .vatsim_only_positions
                .read()
                .await
                .contains(&pos("LOWW_TWR")),
            "LOWW_TWR should be removed from vatsim_only"
        );

        // Stations should now be visible again under LOVV_CTR
        let stations = manager
            .list_stations(&ActiveProfile::Custom, Some(&pos("LOVV_CTR")))
            .await;
        let station_ids: Vec<&str> = stations.iter().map(|s| s.id.as_str()).collect();
        assert!(station_ids.contains(&"LOWW_TWR"));
        assert!(station_ids.contains(&"LOWW_GND"));
        assert!(station_ids.contains(&"LOWW_DEL"));

        // Client should receive Online for the stations that became visible again
        let changes = drain_station_changes(&mut rx);
        assert_eq!(
            changes,
            vec![
                StationChange::Online {
                    station_id: station("LOWW_DEL"),
                    position_id: pos("LOVV_CTR"),
                },
                StationChange::Online {
                    station_id: station("LOWW_GND"),
                    position_id: pos("LOVV_CTR"),
                },
                StationChange::Online {
                    station_id: station("LOWW_TWR"),
                    position_id: pos("LOVV_CTR"),
                },
            ]
        );
    }

    #[tokio::test]
    async fn replace_network_multiple_clients_on_stale_position() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Two clients connect on the same position LOWW_DEL
        let (_client0, mut rx0) = manager
            .add_client(
                client_info("client0", "LOWW_DEL", "122.125"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();
        let (_client1, mut rx1) = manager
            .add_client(
                client_info("client1", "LOWW_DEL", "122.125"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx0);
        drain_station_changes(&mut rx1);

        // Verify both are on the position
        let pos_clients = manager
            .online_positions
            .read()
            .await
            .get(&pos("LOWW_DEL"))
            .cloned()
            .unwrap_or_default();
        assert_eq!(pos_clients.len(), 2);

        // Replace with network that removes LOWW_DEL position
        let new_network = create_lovv_network_without_del(dir.path());
        manager.replace_network(new_network).await;

        // Position should be gone
        assert!(
            !manager
                .online_positions
                .read()
                .await
                .contains_key(&pos("LOWW_DEL")),
        );

        // Both clients should have their position_id cleared
        let c0 = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(c0.position_id(), None, "client0 position should be cleared");
        let c1 = manager.get_client(&cid("client1")).await.unwrap();
        assert_eq!(c1.position_id(), None, "client1 position should be cleared");

        // Both should receive Offline for LOWW_DEL
        let changes0 = drain_station_changes(&mut rx0);
        assert_eq!(
            changes0,
            vec![StationChange::Offline {
                station_id: station("LOWW_DEL"),
            }],
            "client0"
        );
        let changes1 = drain_station_changes(&mut rx1);
        assert_eq!(
            changes1,
            vec![StationChange::Offline {
                station_id: station("LOWW_DEL"),
            }],
            "client1"
        );
    }

    #[tokio::test]
    async fn add_client_vatsim_only_position_not_controlling_any_station() {
        let (_dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // vacs client connects as LOWW_APP (covers LOWW_APP, LOWW_TWR, LOWW_GND, LOWW_DEL)
        let (_client_app, mut rx_app) = manager
            .add_client(
                client_info("client0", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx_app);

        // LOVV_CTR comes online as VATSIM-only. It would cover LOWW_APP station
        // via controlled_by, but LOWW_APP position has higher priority, so
        // LOVV_CTR controls no stations.
        let vatsim_controllers = HashMap::from([
            (
                cid("client0"),
                controller("client0", "LOWW_APP", "134.675", FacilityType::Approach),
            ),
            (
                cid("vatsim_client1"),
                controller(
                    "vatsim_client1",
                    "LOVV_CTR",
                    "132.600",
                    FacilityType::Enroute,
                ),
            ),
        ]);
        manager
            .sync_vatsim_state(&vatsim_controllers, &mut HashSet::new(), false)
            .await;

        // No station changes â€” LOVV_CTR is VATSIM-only but controls nothing
        // (all stations already covered by higher-priority LOWW_APP)
        let changes_after_sync = drain_station_changes(&mut rx_app);
        assert_eq!(changes_after_sync, vec![], "No station changes expected");

        // Now a vacs client connects as LOVV_CTR (was VATSIM-only)
        let (_client_ctr, _rx_ctr) = manager
            .add_client(
                client_info("client1", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // LOVV_CTR was vatsim-only but controlled no stations, so the
        // transition shouldn't produce any Online events for the APP client
        let changes_after_connect = drain_station_changes(&mut rx_app);
        assert_eq!(
            changes_after_connect,
            vec![],
            "No Online events expected â€” LOVV_CTR controls no stations while LOWW_APP is online"
        );

        // LOVV_CTR should no longer be in vatsim_only
        assert!(
            !manager
                .vatsim_only_positions
                .read()
                .await
                .contains(&pos("LOVV_CTR")),
            "LOVV_CTR should be removed from vatsim_only"
        );
    }

    #[tokio::test]
    async fn replace_network_reduces_to_minimal() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Two clients on different positions
        let (_client_ctr, mut rx_ctr) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();
        let (_client_app, mut rx_app) = manager
            .add_client(
                client_info("client1", "LOWW_APP", "134.675"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx_ctr);
        drain_station_changes(&mut rx_app);

        // Verify we have stations and positions
        assert!(!manager.online_stations.read().await.is_empty());
        assert!(!manager.online_positions.read().await.is_empty());

        // Replace with minimal network: only LOVV_CTR position + LOWW_APP station
        let new_network = create_minimal_lovv_network(dir.path());
        manager.replace_network(new_network).await;

        // LOWW_APP position should be gone (doesn't exist in new network)
        assert!(
            !manager
                .online_positions
                .read()
                .await
                .contains_key(&pos("LOWW_APP")),
        );

        // LOVV_CTR position should still exist (it's in the new network)
        assert!(
            manager
                .online_positions
                .read()
                .await
                .contains_key(&pos("LOVV_CTR")),
        );

        // Only LOWW_APP station should remain
        let stations = manager.online_stations.read().await;
        assert_eq!(stations.len(), 1, "Only LOWW_APP station should remain");
        assert!(stations.contains_key(&station("LOWW_APP")));
        drop(stations);

        // LOWW_APP client's position should be cleared (position doesn't exist)
        let c0 = manager.get_client(&cid("client0")).await.unwrap();
        assert_eq!(
            c0.position_id(),
            Some(&pos("LOVV_CTR")),
            "LOVV_CTR still exists in new network"
        );
        let c1 = manager.get_client(&cid("client1")).await.unwrap();
        assert_eq!(
            c1.position_id(),
            None,
            "LOWW_APP position doesn't exist in new network"
        );

        // CTR client: LOWW_TWR/GND/DEL go Offline (removed stations),
        // LOWW_APP transitions LOWW_APPâ†’LOVV_CTR but since LOWW_APP position
        // is gone (removed as stale), client_visible_changes sees it as Online.
        let changes_ctr = drain_station_changes(&mut rx_ctr);
        assert_eq!(
            changes_ctr,
            vec![
                StationChange::Online {
                    station_id: station("LOWW_APP"),
                    position_id: pos("LOVV_CTR"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ],
            "CTR client"
        );

        // APP client: same changes
        let changes_app = drain_station_changes(&mut rx_app);
        assert_eq!(
            changes_app,
            vec![
                StationChange::Online {
                    station_id: station("LOWW_APP"),
                    position_id: pos("LOVV_CTR"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_DEL"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_GND"),
                },
                StationChange::Offline {
                    station_id: station("LOWW_TWR"),
                },
            ],
            "APP client"
        );
    }

    #[tokio::test]
    async fn replace_network_client_without_position_unaffected() {
        let (dir, network) = create_lovv_network();
        let manager = client_manager(network);

        // Position-holding client
        let (_client_ctr, mut rx_ctr) = manager
            .add_client(
                client_info("client0", "LOVV_CTR", "132.600"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        // Client without a position (e.g. position lookup yielded no match)
        let (_client_nopos, mut rx_nopos) = manager
            .add_client(
                client_info_without_position("nopos0"),
                ActiveProfile::Custom,
                ClientConnectionGuard::default(),
            )
            .await
            .unwrap();

        drain_station_changes(&mut rx_ctr);
        drain_station_changes(&mut rx_nopos);

        // Verify client has no position
        let nopos = manager.get_client(&cid("nopos0")).await.unwrap();
        assert_eq!(nopos.position_id(), None);

        // Replace with network that removes LOWW_DEL
        let new_network = create_lovv_network_without_del(dir.path());
        manager.replace_network(new_network).await;

        // No-position client should still be connected with no position
        let nopos = manager.get_client(&cid("nopos0")).await.unwrap();
        assert_eq!(nopos.position_id(), None, "Position should remain None");

        // CTR client should receive Offline for LOWW_DEL
        let changes_ctr = drain_station_changes(&mut rx_ctr);
        assert_eq!(
            changes_ctr,
            vec![StationChange::Offline {
                station_id: station("LOWW_DEL"),
            }]
        );

        // No-position client should also receive Offline for LOWW_DEL
        // (they see all stations via Custom profile)
        let changes_nopos = drain_station_changes(&mut rx_nopos);
        assert_eq!(
            changes_nopos,
            vec![StationChange::Offline {
                station_id: station("LOWW_DEL"),
            }],
            "No-position client should receive station changes too"
        );
    }

    /// Base builder for the standard LOVV FIR used by most tests.
    fn lovv_fir() -> TestFirBuilder {
        TestFirBuilder::new("LOVV")
            .station("LOWW_APP", &["LOWW_APP", "LOVV_CTR"])
            .station_with_parent("LOWW_TWR", "LOWW_APP", &["LOWW_TWR"])
            .station_with_parent("LOWW_GND", "LOWW_TWR", &["LOWW_GND"])
            .station_with_parent("LOWW_DEL", "LOWW_GND", &["LOWW_DEL"])
            .position("LOVV_CTR", &["LOVV"], "132.600", "CTR")
            .position("LOWW_APP", &["LOWW"], "134.675", "APP")
            .position("LOWW_TWR", &["LOWW"], "119.400", "TWR")
            .position("LOWW_GND", &["LOWW"], "121.600", "GND")
            .position("LOWW_DEL", &["LOWW"], "122.125", "DEL")
    }

    /// Standard LOVV network (5 positions, 5 stations). Returns the temp-dir
    /// so the caller can pass it to variants that only rewrite positions/stations.
    fn create_lovv_network() -> (tempfile::TempDir, Network) {
        let dir = tempfile::tempdir().unwrap();
        let network = lovv_fir().build(dir.path());
        (dir, network)
    }

    /// LOVV without the LOWW_DEL position *and* station.
    fn create_lovv_network_without_del(dir: &std::path::Path) -> Network {
        TestFirBuilder::new("LOVV")
            .station("LOWW_APP", &["LOWW_APP", "LOVV_CTR"])
            .station_with_parent("LOWW_TWR", "LOWW_APP", &["LOWW_TWR"])
            .station_with_parent("LOWW_GND", "LOWW_TWR", &["LOWW_GND"])
            .position("LOVV_CTR", &["LOVV"], "132.600", "CTR")
            .position("LOWW_APP", &["LOWW"], "134.675", "APP")
            .position("LOWW_TWR", &["LOWW"], "119.400", "TWR")
            .position("LOWW_GND", &["LOWW"], "121.600", "GND")
            .build(dir)
    }

    /// LOVV with profiles assigned to CTR and APP positions.
    fn create_lovv_network_with_profiles(dir: &std::path::Path) -> Network {
        TestFirBuilder::new("LOVV")
            .station("LOWW_APP", &["LOWW_APP", "LOVV_CTR"])
            .station_with_parent("LOWW_TWR", "LOWW_APP", &["LOWW_TWR"])
            .station_with_parent("LOWW_GND", "LOWW_TWR", &["LOWW_GND"])
            .station_with_parent("LOWW_DEL", "LOWW_GND", &["LOWW_DEL"])
            .position_with_profile("LOVV_CTR", &["LOVV"], "132.600", "CTR", "CTR_PROFILE")
            .position_with_profile("LOWW_APP", &["LOWW"], "134.675", "APP", "APP_PROFILE")
            .position("LOWW_TWR", &["LOWW"], "119.400", "TWR")
            .position("LOWW_GND", &["LOWW"], "121.600", "GND")
            .position("LOWW_DEL", &["LOWW"], "122.125", "DEL")
            .tabbed_profile(
                "CTR_PROFILE",
                &[("LOWW APP", "LOWW_APP"), ("LOWW TWR", "LOWW_TWR")],
            )
            .tabbed_profile(
                "APP_PROFILE",
                &[("LOWW TWR", "LOWW_TWR"), ("LOWW GND", "LOWW_GND")],
            )
            .build(dir)
    }

    /// LOVV with LOWW_APP's profile reassigned to CTR_PROFILE.
    /// Only rewrites positions.toml â€” stations and profiles remain from a
    /// previous `create_lovv_network_with_profiles` call.
    fn create_lovv_network_with_reassigned_profile(dir: &std::path::Path) -> Network {
        TestFirBuilder::new("LOVV")
            .position_with_profile("LOVV_CTR", &["LOVV"], "132.600", "CTR", "CTR_PROFILE")
            .position_with_profile("LOWW_APP", &["LOWW"], "134.675", "APP", "CTR_PROFILE")
            .position("LOWW_TWR", &["LOWW"], "119.400", "TWR")
            .position("LOWW_GND", &["LOWW"], "121.600", "GND")
            .position("LOWW_DEL", &["LOWW"], "122.125", "DEL")
            .build(dir)
    }

    /// LOVV with an extra LOVV_N1 station controlled by LOVV_CTR.
    fn create_lovv_network_with_extra_station(dir: &std::path::Path) -> Network {
        lovv_fir().station("LOVV_N1", &["LOVV_CTR"]).build(dir)
    }

    /// Creates a network without the LOWW_TWR position.
    /// LOWW_TWR *station* remains (falls back to parent LOWW_APP).
    fn create_lovv_network_without_twr_position(dir: &std::path::Path) -> Network {
        TestFirBuilder::new("LOVV")
            .station("LOWW_APP", &["LOWW_APP", "LOVV_CTR"])
            .station_with_parent("LOWW_TWR", "LOWW_APP", &["LOWW_APP", "LOVV_CTR"])
            .station_with_parent("LOWW_GND", "LOWW_TWR", &["LOWW_GND"])
            .station_with_parent("LOWW_DEL", "LOWW_GND", &["LOWW_DEL"])
            .position("LOVV_CTR", &["LOVV"], "132.600", "CTR")
            .position("LOWW_APP", &["LOWW"], "134.675", "APP")
            .position("LOWW_GND", &["LOWW"], "121.600", "GND")
            .position("LOWW_DEL", &["LOWW"], "122.125", "DEL")
            .build(dir)
    }

    /// Creates a minimal network with only LOVV_CTR position and one station.
    fn create_minimal_lovv_network(dir: &std::path::Path) -> Network {
        TestFirBuilder::new("LOVV")
            .station("LOWW_APP", &["LOVV_CTR"])
            .position("LOVV_CTR", &["LOVV"], "132.600", "CTR")
            .build(dir)
    }
}
